import re

import click

from infra.tools.ghsync.utils.db import TABLE_DEFINITIONS


def _convert_column_def_to_elisp(col_name, col_def):
    parts = col_def.upper().split()
    col_type = parts[0].lower()

    elisp_def = [f"({col_name}", col_type]

    i = 1
    while i < len(parts):
        part = parts[i]
        if part == "PRIMARY" and i + 1 < len(parts) and parts[i + 1] == "KEY":
            elisp_def.append(":primary-key")
            i += 2
        elif part == "NOT" and i + 1 < len(parts) and parts[i + 1] == "NULL":
            elisp_def.append(":not-null")
            i += 2
        elif part == "UNIQUE":
            elisp_def.append(":unique")
            i += 1
        elif part == "DEFAULT":
            if i + 1 < len(parts):
                elisp_def.append(f":default {parts[i+1]}")
            i += 2
        else:
            # unhandled part, just increment
            i += 1

    return " ".join(elisp_def) + ")"


def _convert_table_constraint_to_elisp(constraint_def):
    constraint_def = constraint_def.strip()

    pk_match = re.match(r"PRIMARY KEY \((.*)\)", constraint_def, re.IGNORECASE)
    if pk_match:
        cols = [c.strip() for c in pk_match.group(1).split(",")]
        return f"(:primary-key {' '.join(cols)})"

    unique_match = re.match(r"UNIQUE\((.*)\)", constraint_def, re.IGNORECASE)
    if unique_match:
        cols = [c.strip() for c in unique_match.group(1).split(",")]
        return f"(:unique {' '.join(cols)})"

    fk_match = re.match(
        r"FOREIGN KEY \((.*)\) REFERENCES (.*) \((.*)\)", constraint_def, re.IGNORECASE
    )
    if fk_match:
        local_cols = [c.strip() for c in fk_match.group(1).split(",")]
        remote_table = fk_match.group(2).strip()
        remote_cols = [c.strip() for c in fk_match.group(3).split(",")]
        return f"(:foreign-key ({' '.join(local_cols)}) ({remote_table} {' '.join(remote_cols)}))"

    return None


@click.command()
@click.option(
    "--output",
    type=click.File("w"),
    default="-",
    help="Output file for the schema. Defaults to stdout.",
)
def schema(output):
    """Outputs database schemas in elisp format."""
    comment = """;;; -*- lexical-binding: t -*-
;;;
;;; This file is automatically generated. DO NOT EDIT.
;;;
;;; To regenerate, run:
;;;   bazel run infra/tools/ghsync:main -- schema --output <path-to-this-file>
"""
    print(comment, file=output)
    print("'(", file=output)
    for table_name, definition in TABLE_DEFINITIONS.items():
        print(f"  ({table_name}", file=output)
        print("   [", file=output)
        for col_name, col_type in definition["columns"]:
            print(f"    {_convert_column_def_to_elisp(col_name, col_type)}", file=output)
        print("   ]", file=output)
        for constraint in definition.get("constraints", []):
            elisp_constraint = _convert_table_constraint_to_elisp(constraint)
            if elisp_constraint:
                print(f"   {elisp_constraint}", file=output)
        print("  )", file=output)
    print(")", file=output)
