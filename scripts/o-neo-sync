#!/usr/bin/env python3
import click
import tarfile
import os
import tempfile
from pathlib import Path
import sys
import subprocess
import hashlib

# Determine the project root relative to this script
# Script is in devex/editors/emacs/scripts/o-neo-sync
# Config root is devex/editors/emacs
SCRIPT_DIR = Path(__file__).resolve().parent
CONFIG_ROOT = SCRIPT_DIR.parent

@click.command()
@click.option('--devel', is_flag=True, help='Development mode sync.')
@click.option('--vm', default='emacs', help='Target VM name (default: emacs).')
def cli(devel, vm):
    """Sync Neo configuration."""
    if devel:
        tar_path = perform_devel_sync()
        if tar_path:
            copy_to_vm(tar_path, vm)
            
            # Remote operations: clean old dir, extract new tarball, remove tarball
            filename = os.path.basename(tar_path)
            click.echo(f"Updating remote configuration...")
            remote_cmds = f"rm -rf neo && tar xf {filename} && rm {filename}"
            run_remote_command(vm, remote_cmds)
            
            # Cleanup local
            try:
                os.remove(tar_path)
            except OSError:
                pass

def perform_devel_sync():
    """Tar the content of the config directory (excluding extensions, scripts, and BUILD.bazel) to a temp file."""
    if not CONFIG_ROOT.exists():
        click.echo(f"Error: Configuration root {CONFIG_ROOT} does not exist.", err=True)
        sys.exit(1)

    # Create a temporary file
    fd, temp_path = tempfile.mkstemp(suffix='.tar.gz')
    os.close(fd)

    click.echo(f"Creating development tarball at: {temp_path}")

    try:
        with tarfile.open(temp_path, "w:gz") as tar:
            # Walk the configuration directory
            for root, dirs, files in os.walk(CONFIG_ROOT):
                root_path = Path(root)
                
                # Exclude 'extensions' and 'scripts' directories from traversal
                for skip_dir in ["extensions", "scripts"]:
                    if skip_dir in dirs:
                        dirs.remove(skip_dir)
                
                for file in files:
                    # Skip BUILD.bazel
                    if file == "BUILD.bazel":
                        continue

                    file_path = root_path / file
                    
                    # Calculate relative path from CONFIG_ROOT
                    rel_path = file_path.relative_to(CONFIG_ROOT)
                    
                    # Map to 'neo' top-level directory
                    arcname = Path("neo") / rel_path
                    
                    tar.add(file_path, arcname=str(arcname))
                    
        click.echo("Tarball created successfully.")
        return temp_path
        
    except Exception as e:
        click.echo(f"Error creating tarball: {e}", err=True)
        if os.path.exists(temp_path):
            os.remove(temp_path)
        sys.exit(1)

def get_ssh_port(vm_name):
    """Generate a deterministic SSH port based on VM name.
    Must match logic in infra/tools/vm_manager/vm_cli.py
    """
    hash_object = hashlib.md5(vm_name.encode())
    # Use ports 20000-29999
    return 20000 + (int(hash_object.hexdigest(), 16) % 10000)

def copy_to_vm(file_path, vm_name):
    """Copy file to VM using SCP via localhost port forwarding."""
    ssh_port = get_ssh_port(vm_name)
    click.echo(f"Calculated SSH port {ssh_port} for VM '{vm_name}'.")

    user = os.environ.get("USER")
    key_path = os.path.expanduser("~/.ssh/id_rsa")
    
    # Destination in user's home directory via localhost
    dest = f"{user}@127.0.0.1:~/"
    
    cmd = [
        "scp",
        "-P", str(ssh_port),
        "-i", key_path,
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        file_path,
        dest
    ]
    
    click.echo(f"Copying to {dest} on port {ssh_port}...")
    try:
        subprocess.run(cmd, check=True)
        click.echo("Copy successful.")
    except subprocess.CalledProcessError as e:
        click.echo(f"SCP failed: {e}", err=True)
        sys.exit(1)

def run_remote_command(vm_name, command):
    """Run a command on the VM via SSH."""
    ssh_port = get_ssh_port(vm_name)
    user = os.environ.get("USER")
    key_path = os.path.expanduser("~/.ssh/id_rsa")

    ssh_cmd = [
        "ssh",
        "-p", str(ssh_port),
        "-i", key_path,
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        f"{user}@127.0.0.1",
        command
    ]

    click.echo(f"Running remote command: {command}")
    try:
        subprocess.run(ssh_cmd, check=True)
        click.echo("Remote command executed successfully.")
    except subprocess.CalledProcessError as e:
        click.echo(f"Remote command failed: {e}", err=True)
        sys.exit(1)

if __name__ == '__main__':
    cli()